import datetime
import discord
from discord import app_commands
from discord.ext import commands

from config import config
from utils.image_gen_utils import generate_random_image, validate_dimensions
from utils.embed_utils import SafeEmbed
from views.cross_pollinate_view import CrossPollinateView
from cogs.base_command_cog import BaseCommandCog


class RandomImage(BaseCommandCog):
    """Refactored random command using the new architecture."""

    def __init__(self, bot: commands.Bot) -> None:
        super().__init__(bot, "random")  # Automatically loads config.commands.random

    async def cog_load(self) -> None:
        """Setup the cog with the cross-pollinate view."""
        await super().cog_load()  # Handles common setup + logging
        self.bot.add_view(CrossPollinateView())

    def get_view_class(self):
        """Return the view class for this command."""
        return CrossPollinateView

    @app_commands.command(name="random", description="Generate Random AI Images")
    @app_commands.choices(
        model=[
            app_commands.Choice(name=choice, value=choice) for choice in config.MODELS
        ],
    )
    @app_commands.guild_only()
    @app_commands.checks.cooldown(
        config.commands["random"].cooldown.rate,
        config.commands["random"].cooldown.seconds,
    )
    @app_commands.describe(
        height="Height of the image",
        width="Width of the image",
        model="The model to use for generating the image",
        negative="The things not to include in the image",
        nologo="Remove the logo",
        private="Only you can see the generated Image if set to True",
    )
    async def random_image_command(
        self,
        interaction: discord.Interaction,
        width: int = config.commands["random"].default_width,
        height: int = config.commands["random"].default_height,
        model: app_commands.Choice[str] = config.MODELS[0],
        negative: str | None = None,
        nologo: bool = config.image_generation.defaults.nologo,
        private: bool = config.image_generation.defaults.private,
    ) -> None:
        # Validation
        validate_dimensions(width, height)

        await interaction.response.defer(thinking=True, ephemeral=private)

        # Extract model value
        model_value = model.value if hasattr(model, "value") else model

        # Log generation start
        start = datetime.datetime.now()
        self.log_generation_start(
            model=model_value or "default",
            dimensions={"width": width, "height": height},
            cached=False,
            action="random_generate",
        )

        try:
            # Generate random image using new utility
            dic, image = await generate_random_image(
                width=width,
                height=height,
                model=model_value,
                negative=negative,
                nologo=nologo,
                private=private,
            )

            # Log completion
            time_taken = (datetime.datetime.now() - start).total_seconds()
            self.log_generation_complete(
                model=model_value or "default",
                dimensions={"width": width, "height": height},
                generation_time=time_taken,
                cached=False,
                action="random_generate",
            )

            # Prepare response
            image_file = discord.File(image, filename="image.png")
            if dic["nsfw"]:
                image_file.filename = f"SPOILER_{image_file.filename}"

            time_taken_delta = datetime.datetime.now() - start

            embed = SafeEmbed(
                title="Random Prompt",
                description=f"```{dic['enhanced_prompt']}```"
                if "enhanced_prompt" in dic and dic["enhanced_prompt"]
                else "```Random generated prompt```",
                timestamp=datetime.datetime.now(datetime.timezone.utc),
                url=dic["url"],
            )

            embed.add_field(name="Seed", value=f"```{dic['seed']}```", inline=True)
            embed.add_field(
                name="Processing Time",
                value=f"```{round(time_taken_delta.total_seconds(), 2)} s```",
                inline=True,
            )
            embed.add_field(
                name="Model", value=f"```{model_value or 'default'}```", inline=True
            )
            embed.add_field(
                name="Dimensions", value=f"```{width}x{height}```", inline=True
            )

            if not private:
                embed.set_image(url="attachment://image.png")
                embed.set_user_footer(interaction, "ðŸŽ² Generated by")
            else:
                embed.set_image(url=dic["url"])

            # Send response using base class method
            if private:
                await self.send_response(interaction, embed, ephemeral=True)
            else:
                await self.send_response(interaction, embed, file=image_file)

        except Exception:
            # All error handling is automatically handled by base class
            raise

    @random_image_command.error
    async def random_image_command_error(
        self, interaction: discord.Interaction, error: app_commands.AppCommandError
    ) -> None:
        """Handle command errors using centralized error handling."""
        await self.handle_command_error(
            interaction,
            error,
            model=getattr(interaction.namespace, "model", "unknown"),
            width=getattr(interaction.namespace, "width", 0),
            height=getattr(interaction.namespace, "height", 0),
        )


async def setup(bot) -> None:
    """Setup function for the cog."""
    await bot.add_cog(RandomImage(bot))
